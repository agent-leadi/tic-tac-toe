<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Tic Tac Toe</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #030310; font-family: 'Segoe UI', system-ui, sans-serif; user-select: none; }
    canvas { display: block; }

    #hud {
      position: fixed; top: 0; left: 0; right: 0;
      display: flex; align-items: flex-start; justify-content: space-between;
      padding: 18px 22px; pointer-events: none; z-index: 10;
    }
    .card {
      background: rgba(8,8,30,0.78); border: 1px solid rgba(255,255,255,0.13);
      backdrop-filter: blur(14px); border-radius: 14px;
      padding: 14px 20px; color: #fff; text-align: center; min-width: 88px;
    }
    .card-label { font-size: 11px; letter-spacing: 2.5px; text-transform: uppercase; opacity: 0.48; margin-bottom: 4px; }
    .card-value { font-size: 38px; font-weight: 800; line-height: 1; }
    .x-card  .card-value { color: #ff2d78; text-shadow: 0 0 22px #ff2d78aa; }
    .o-card  .card-value { color: #00f5ff; text-shadow: 0 0 22px #00f5ffaa; }

    #status-card { flex: 1; margin: 0 16px; text-align: center; padding: 16px 24px; }
    #status-text { font-size: 18px; font-weight: 700; letter-spacing: 1.5px; transition: color .3s, text-shadow .3s; }

    #dot {
      display: inline-block; width: 10px; height: 10px;
      border-radius: 50%; margin-right: 8px; vertical-align: middle;
      animation: blink 1.2s ease-in-out infinite;
    }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.25} }

    #hint {
      position: fixed; bottom: 88px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.22); font-size: 12px; letter-spacing: 1px;
      pointer-events: none; z-index: 10;
    }
    #controls {
      position: fixed; bottom: 26px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; z-index: 10;
    }
    button {
      background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.22);
      color: rgba(255,255,255,0.88); padding: 11px 28px; border-radius: 30px;
      font-size: 13px; font-weight: 600; letter-spacing: 1.2px; cursor: pointer;
      transition: background .2s, transform .15s, border-color .2s;
      backdrop-filter: blur(10px);
    }
    button:hover { background: rgba(255,255,255,0.16); border-color: rgba(255,255,255,0.5); transform: translateY(-2px); }
    button:active { transform: translateY(0); }

    #win-banner {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      pointer-events: none; z-index: 20; opacity: 0; transition: opacity .4s;
    }
    #win-banner.visible { opacity: 1; }
    #win-text {
      font-size: 66px; font-weight: 900; letter-spacing: 4px; color: #fff;
      animation: pulsate .55s ease-in-out infinite alternate;
    }
    @keyframes pulsate { from{transform:scale(1);filter:brightness(1)} to{transform:scale(1.07);filter:brightness(1.4)} }
  </style>
</head>
<body>

<div id="hud">
  <div class="card x-card">
    <div class="card-label">Player X</div>
    <div class="card-value" id="score-x">0</div>
  </div>
  <div class="card" id="status-card">
    <div id="status-text"><span id="dot" style="background:#ff2d78;box-shadow:0 0 10px #ff2d78"></span>Player X's Turn</div>
  </div>
  <div class="card o-card">
    <div class="card-label">Player O</div>
    <div class="card-value" id="score-o">0</div>
  </div>
</div>

<div id="win-banner"><div id="win-text"></div></div>
<div id="hint">Drag to orbit &nbsp;Â·&nbsp; Scroll to zoom</div>
<div id="controls">
  <button id="btn-new">New Game</button>
  <button id="btn-reset">Reset Score</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
'use strict';

// â”€â”€â”€ RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x030310);
scene.fog = new THREE.FogExp2(0x030310, 0.030);

// â”€â”€â”€ CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const camera = new THREE.PerspectiveCamera(52, innerWidth / innerHeight, 0.1, 300);
camera.position.set(0, 8, 12);
camera.lookAt(0, 0, 0);

const orbit = { theta: 0, phi: 0.82, r: 14 };
const camBase   = new THREE.Vector3(0, 8, 12);
const camTarget = new THREE.Vector3(0, 8, 12);

function orbitRefresh() {
  camBase.set(
    orbit.r * Math.sin(orbit.phi) * Math.sin(orbit.theta),
    orbit.r * Math.cos(orbit.phi),
    orbit.r * Math.sin(orbit.phi) * Math.cos(orbit.theta)
  );
}

let dragging = false, lmx = 0, lmy = 0, clickedThisDown = true;
renderer.domElement.addEventListener('mousedown', e => { dragging = false; lmx = e.clientX; lmy = e.clientY; clickedThisDown = true; });
window.addEventListener('mousemove', e => {
  const dx = e.clientX - lmx, dy = e.clientY - lmy;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) { clickedThisDown = false; }
  if (!clickedThisDown) { dragging = true; }
  if (dragging) {
    orbit.theta -= dx * 0.006;
    orbit.phi = Math.max(0.28, Math.min(1.35, orbit.phi - dy * 0.005));
    lmx = e.clientX; lmy = e.clientY;
    orbitRefresh();
  }
});
window.addEventListener('mouseup', () => { dragging = false; });
window.addEventListener('wheel', e => {
  orbit.r = Math.max(7, Math.min(22, orbit.r + e.deltaY * 0.013));
  orbitRefresh();
}, { passive: true });

// â”€â”€â”€ LIGHTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0x112255, 1.3));
const sun = new THREE.DirectionalLight(0xffffff, 0.65);
sun.position.set(6, 15, 8);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

const xLight = new THREE.PointLight(0xff2d78, 4.5, 24);
xLight.position.set(-5, 5, 3);
scene.add(xLight);

const oLight = new THREE.PointLight(0x00f5ff, 4.5, 24);
oLight.position.set(5, 5, -3);
scene.add(oLight);

const fillLight = new THREE.PointLight(0x5500ff, 2.2, 14);
fillLight.position.set(0, -1.5, 0);
scene.add(fillLight);

// â”€â”€â”€ STARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function () {
  const N = 4500, pos = new Float32Array(N * 3), col = new Float32Array(N * 3);
  const palettes = [[1,.65,1],[.55,.8,1],[1,1,1],[.65,1,1],[1,.9,.65]];
  for (let i = 0; i < N; i++) {
    const r = 90 + Math.random() * 100;
    const th = Math.random() * Math.PI * 2, ph = Math.acos(2 * Math.random() - 1);
    pos[i*3]   = r * Math.sin(ph) * Math.cos(th);
    pos[i*3+1] = r * Math.sin(ph) * Math.sin(th);
    pos[i*3+2] = r * Math.cos(ph);
    const c = palettes[Math.floor(Math.random() * palettes.length)];
    col[i*3] = c[0]; col[i*3+1] = c[1]; col[i*3+2] = c[2];
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color',    new THREE.BufferAttribute(col, 3));
  const mat = new THREE.PointsMaterial({ size: 0.19, vertexColors: true, sizeAttenuation: true, transparent: true, opacity: 0.88 });
  window._stars = new THREE.Points(geo, mat);
  scene.add(window._stars);
})();

// â”€â”€â”€ NEBULA PLANES (background atmosphere) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(function () {
  const colors = [0xff1166, 0x0044ff, 0x00ccff, 0x9900ff];
  colors.forEach((c, i) => {
    const geo = new THREE.PlaneGeometry(80, 80);
    const mat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.03 + Math.random() * 0.03, side: THREE.DoubleSide, depthWrite: false });
    const m = new THREE.Mesh(geo, mat);
    m.position.set((Math.random()-.5)*60, (Math.random()-.5)*40, -60 - Math.random()*40);
    m.rotation.z = Math.random() * Math.PI;
    scene.add(m);
  });
})();

// â”€â”€â”€ BOARD GROUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const board3D = new THREE.Group();
scene.add(board3D);

// Platform
const platMesh = new THREE.Mesh(
  new THREE.BoxGeometry(6.7, 0.18, 6.7),
  new THREE.MeshStandardMaterial({
    color: 0x07072c, emissive: 0x040424, emissiveIntensity: 0.6,
    metalness: 0.9, roughness: 0.1, transparent: true, opacity: 0.9
  })
);
platMesh.position.y = -0.09;
platMesh.receiveShadow = true;
board3D.add(platMesh);

// Edge glow ring beneath platform
const edgeRing = new THREE.Mesh(
  new THREE.TorusGeometry(4.1, 0.05, 10, 80),
  new THREE.MeshBasicMaterial({ color: 0x4433ff, transparent: true, opacity: 0.5 })
);
edgeRing.position.y = -0.18;
edgeRing.rotation.x = Math.PI / 2;
board3D.add(edgeRing);

// Grid line helper
function gline(w, h, d, x, y, z) {
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(w, h, d),
    new THREE.MeshStandardMaterial({ color: 0x2244ff, emissive: 0x2244ff, emissiveIntensity: 2.5, metalness: 0.2, roughness: 0.3 })
  );
  m.position.set(x, y, z);
  board3D.add(m); return m;
}
gline(0.07, 0.09, 6.5,  -1, 0.02, 0);
gline(0.07, 0.09, 6.5,   1, 0.02, 0);
gline(6.5,  0.09, 0.07, 0, 0.02, -1);
gline(6.5,  0.09, 0.07, 0, 0.02,  1);

// Intersection dots
const dotG = new THREE.SphereGeometry(0.075, 10, 10);
const dotM = new THREE.MeshStandardMaterial({ color: 0x8899ff, emissive: 0x5566ff, emissiveIntensity: 2.5 });
[[-3.25,0,-3.25],[0,0,-3.25],[3.25,0,-3.25],[-3.25,0,0],[0,0,0],[3.25,0,0],[-3.25,0,3.25],[0,0,3.25],[3.25,0,3.25],
 [-1,0,-1],[1,0,-1],[-1,0,1],[1,0,1]].forEach(([x,,z]) => {
  const d = new THREE.Mesh(dotG, dotM);
  d.position.set(x, 0.075, z);
  board3D.add(d);
});

// Floating orbit ring
const orbitRing = new THREE.Mesh(
  new THREE.TorusGeometry(5.5, 0.042, 12, 90),
  new THREE.MeshBasicMaterial({ color: 0x3322cc, transparent: true, opacity: 0.3 })
);
orbitRing.rotation.x = Math.PI / 2;
board3D.add(orbitRing);

// Second tilted orbit ring
const orbitRing2 = new THREE.Mesh(
  new THREE.TorusGeometry(4.8, 0.028, 10, 80),
  new THREE.MeshBasicMaterial({ color: 0xff2d78, transparent: true, opacity: 0.18 })
);
orbitRing2.rotation.x = Math.PI / 2;
orbitRing2.rotation.z = Math.PI / 5;
board3D.add(orbitRing2);

// â”€â”€â”€ CELL HIT PLANES & HOVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CELLS = [
  [-2,0,-2],[0,0,-2],[2,0,-2],
  [-2,0, 0],[0,0, 0],[2,0, 0],
  [-2,0, 2],[0,0, 2],[2,0, 2],
];
const hitPlanes = [], glowQuads = [];

CELLS.forEach(([cx,,cz], i) => {
  const hp = new THREE.Mesh(
    new THREE.PlaneGeometry(1.9, 1.9),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
  );
  hp.rotation.x = -Math.PI / 2;
  hp.position.set(cx, 0.06, cz);
  hp.userData.ci = i;
  board3D.add(hp);
  hitPlanes.push(hp);

  const gq = new THREE.Mesh(
    new THREE.PlaneGeometry(1.88, 1.88),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, side: THREE.DoubleSide })
  );
  gq.rotation.x = -Math.PI / 2;
  gq.position.set(cx, 0.045, cz);
  board3D.add(gq);
  glowQuads.push(gq);
});

// â”€â”€â”€ PIECE BUILDERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeX(win = false) {
  const col  = win ? 0xff80b0 : 0xff2d78;
  const eInt = win ? 5 : 2.2;
  const mat  = () => new THREE.MeshStandardMaterial({ color: col, emissive: col, emissiveIntensity: eInt, metalness: 0.15, roughness: 0.3 });
  const cylG = new THREE.CylinderGeometry(0.088, 0.088, 1.18, 14);
  const b1 = new THREE.Mesh(cylG, mat()); b1.rotation.set(Math.PI/2, 0,  Math.PI/4); b1.position.y = 0.65;
  const b2 = new THREE.Mesh(cylG, mat()); b2.rotation.set(Math.PI/2, 0, -Math.PI/4); b2.position.y = 0.65;
  // Tip spheres
  const tipG = new THREE.SphereGeometry(0.088, 10, 10);
  const offsets = [
    [  0.59 * Math.cos( Math.PI/4),  0.65,  0.59 * Math.sin( Math.PI/4)],
    [ -0.59 * Math.cos( Math.PI/4),  0.65, -0.59 * Math.sin( Math.PI/4)],
    [  0.59 * Math.cos(-Math.PI/4),  0.65,  0.59 * Math.sin(-Math.PI/4)],
    [ -0.59 * Math.cos(-Math.PI/4),  0.65, -0.59 * Math.sin(-Math.PI/4)],
  ];
  const grp = new THREE.Group();
  grp.add(b1, b2);
  offsets.forEach(([x,y,z]) => {
    const s = new THREE.Mesh(tipG, mat());
    s.position.set(x, y, z);
    grp.add(s);
  });
  grp.scale.setScalar(0.001);
  return grp;
}

function makeO(win = false) {
  const col  = win ? 0x80ffff : 0x00f5ff;
  const eInt = win ? 5 : 2.2;
  const mat  = new THREE.MeshStandardMaterial({ color: col, emissive: col, emissiveIntensity: eInt, metalness: 0.15, roughness: 0.3 });
  const torus = new THREE.Mesh(new THREE.TorusGeometry(0.46, 0.1, 20, 52), mat);
  torus.rotation.x = Math.PI / 2;
  torus.position.y = 0.65;
  const grp = new THREE.Group();
  grp.add(torus);
  grp.scale.setScalar(0.001);
  return grp;
}

// â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let particles = [];

function burst(wx, wz, color, count = 60) {
  const baseY = board3D.position.y + 0.6;
  for (let i = 0; i < count; i++) {
    const geo = new THREE.SphereGeometry(0.04 + Math.random() * 0.045, 5, 5);
    const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
    const p   = new THREE.Mesh(geo, mat);
    p.position.set(wx, baseY, wz);
    const spd = 0.065 + Math.random() * 0.095;
    const ang = Math.random() * Math.PI * 2, el = Math.random() * Math.PI;
    p.userData.v = new THREE.Vector3(
      Math.sin(el) * Math.cos(ang) * spd,
      Math.cos(el) * spd + 0.045,
      Math.sin(el) * Math.sin(ang) * spd
    );
    p.userData.life  = 1.0;
    p.userData.decay = 0.011 + Math.random() * 0.013;
    scene.add(p);
    particles.push(p);
  }
}

function tickParticles() {
  particles = particles.filter(p => {
    p.userData.life -= p.userData.decay;
    if (p.userData.life <= 0) { scene.remove(p); return false; }
    p.position.addScaledVector(p.userData.v, 1);
    p.userData.v.y -= 0.004;
    p.scale.setScalar(p.userData.life);
    p.material.opacity = p.userData.life;
    return true;
  });
}

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WIN_LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
let gameBoard = Array(9).fill(null), currentP = 'X', gameOver = false;
let pieces3D  = Array(9).fill(null), score = { X: 0, O: 0 };
let animQ = [], shakeAmt = 0, shakeT = 0;

function checkResult() {
  for (const [a,b,c] of WIN_LINES)
    if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c])
      return { winner: gameBoard[a], cells: [a,b,c] };
  if (gameBoard.every(Boolean)) return { winner: 'draw', cells: [] };
  return null;
}

function setStatus(txt, col) {
  document.getElementById('status-text').innerHTML =
    `<span id="dot" style="display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:8px;vertical-align:middle;background:${col};box-shadow:0 0 10px ${col};animation:blink 1.2s ease-in-out infinite"></span>${txt}`;
}

function showBanner(txt, col) {
  const wt = document.getElementById('win-text');
  wt.textContent = txt;
  wt.style.color = col;
  wt.style.textShadow = `0 0 60px ${col}`;
  document.getElementById('win-banner').classList.add('visible');
  setTimeout(() => document.getElementById('win-banner').classList.remove('visible'), 2800);
}

function placePiece(ci) {
  if (gameBoard[ci] || gameOver) return;
  gameBoard[ci] = currentP;
  const [cx,,cz] = CELLS[ci];
  const piece = currentP === 'X' ? makeX() : makeO();
  piece.position.set(cx, 0, cz);
  board3D.add(piece);
  pieces3D[ci] = piece;
  animQ.push({ mesh: piece, target: 1, spd: 0.1 });

  const result = checkResult();
  if (result) {
    gameOver = true;
    if (result.winner === 'draw') {
      burst(0, 0, 0xffe600, 100);
      shakeAmt = 0.45; shakeT = 0;
      setTimeout(() => { setStatus("IT'S A DRAW!", '#ffe600'); showBanner('DRAW!', '#ffe600'); }, 250);
    } else {
      score[result.winner]++;
      document.getElementById(`score-${result.winner.toLowerCase()}`).textContent = score[result.winner];
      const col = result.winner === 'X' ? '#ff2d78' : '#00f5ff';
      const hex = result.winner === 'X' ? 0xff2d78 : 0x00f5ff;
      result.cells.forEach(i => {
        const [bx,,bz] = CELLS[i];
        burst(bx, bz, hex, 55);
        if (pieces3D[i]) pieces3D[i].traverse(c => {
          if (c.material) { c.material.emissiveIntensity = 5.5; c.material.emissive.setHex(hex); }
        });
      });
      shakeAmt = 1.0; shakeT = 0;
      setTimeout(() => { setStatus(`Player ${result.winner} Wins!`, col); showBanner(`${result.winner} WINS! ðŸŽ‰`, col); }, 250);
    }
  } else {
    currentP = currentP === 'X' ? 'O' : 'X';
    setStatus(`Player ${currentP}'s Turn`, currentP === 'X' ? '#ff2d78' : '#00f5ff');
  }
}

function newGame() {
  gameBoard = Array(9).fill(null); currentP = 'X'; gameOver = false;
  pieces3D.forEach(p => { if (p) board3D.remove(p); }); pieces3D = Array(9).fill(null);
  particles.forEach(p => scene.remove(p)); particles = [];
  animQ = [];
  document.getElementById('win-banner').classList.remove('visible');
  setStatus("Player X's Turn", '#ff2d78');
}

document.getElementById('btn-new').addEventListener('click', newGame);
document.getElementById('btn-reset').addEventListener('click', () => {
  score = { X: 0, O: 0 };
  document.getElementById('score-x').textContent = 0;
  document.getElementById('score-o').textContent = 0;
  newGame();
});

// â”€â”€â”€ RAYCASTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ray   = new THREE.Raycaster();
const mouse = new THREE.Vector2(-99, -99);
window.addEventListener('mousemove', e => {
  mouse.x =  (e.clientX / innerWidth)  * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});
renderer.domElement.addEventListener('click', () => {
  if (dragging) return;
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(hitPlanes);
  if (hits.length) placePiece(hits[0].object.userData.ci);
});

// â”€â”€â”€ LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const t  = clock.elapsedTime;

  // Stars slow drift
  if (window._stars) window._stars.rotation.y += 0.00022;

  // Board float
  board3D.position.y = Math.sin(t * 0.65) * 0.15;
  board3D.rotation.y = Math.sin(t * 0.22) * 0.045;

  // Ring spins
  orbitRing.rotation.z  =  t * 0.38;
  orbitRing2.rotation.z = -t * 0.55;
  edgeRing.rotation.z   =  t * 0.12;

  // Light pulse
  xLight.intensity   = 4.0 + Math.sin(t * 1.9) * 0.7;
  oLight.intensity   = 4.0 + Math.sin(t * 2.2 + 1.1) * 0.7;
  fillLight.intensity = 1.8 + Math.sin(t * 1.1) * 0.5;

  // Camera smoothing
  camTarget.lerp(camBase, 0.055);
  let sx = 0, sy = 0;
  if (shakeAmt > 0) {
    shakeT += dt;
    const decay = Math.max(0, shakeAmt - shakeT * 1.6);
    sx = (Math.random() - 0.5) * decay * 0.45;
    sy = (Math.random() - 0.5) * decay * 0.45;
  }
  camera.position.set(camTarget.x + sx, camTarget.y + sy, camTarget.z);
  camera.lookAt(0, 0, 0);

  // Pop-in animation
  animQ = animQ.filter(item => {
    const s = Math.min(item.mesh.scale.x + item.spd, item.target);
    item.mesh.scale.setScalar(s);
    return s < item.target;
  });

  // Hover glow
  ray.setFromCamera(mouse, camera);
  const hh = ray.intersectObjects(hitPlanes);
  const hci = hh.length ? hh[0].object.userData.ci : -1;
  const pHex = currentP === 'X' ? 0xff2d78 : 0x00f5ff;
  glowQuads.forEach((gq, i) => {
    const want = (i === hci && !gameBoard[i] && !gameOver) ? 0.11 : 0;
    gq.material.opacity += (want - gq.material.opacity) * 0.18;
    gq.material.color.setHex(pHex);
  });

  tickParticles();
  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

setStatus("Player X's Turn", '#ff2d78');
</script>
</body>
</html>
